1. Важность обработки ошибок

Ошибки возникают всегда в реальных программах. Без обработки:

Программа может аварийно завершиться
Возвращаться некорректные данные или "мусор"
Возникают логические ошибки (программа работает, но неправильно)
Примеры: файл не открылся, индекс вне границ, нехватка памяти

2. Три основных подхода в C++

2.1. Коды возврата (устаревший способ)

Принцип: Функция возвращает специальное значение, указывающее на успех/ошибку
Недостатки:

Легко забыть проверить возвращаемое значение
Код превращается в цепочку проверок if
Плохо масштабируется для сложных программ
Загрязняет сигнатуры функций

2.2. Исключения (try/catch/throw)

Принцип: Отделение нормального потока выполнения от обработки ошибок

Ключевые элементы:

throw - генерация исключения
try - блок кода, где могут возникнуть исключения
catch - блок обработки исключений

Иерархия стандартных исключений:

std::exception - базовый класс
std::runtime_error - ошибки времени выполнения
std::logic_error - логические ошибки
std::out_of_range - выход за границы
std::invalid_argument - неверный аргумент

Рекомендация: Ловить исключения по ссылке (catch (const std::exception& e))

Когда НЕ использовать исключения:

Для обычных условий (вместо if)
Для управления логикой программы
В "горячих" участках кода (где важна производительность)

2.3. Типы-обёртки (современный подход)

std::optional<T>

Принцип: Функция может вернуть либо значение типа T, либо ничего
Использовать когда:

Отсутствие значения - нормальная ситуация
Нет необходимости в исключении
Простой вариант обработки "отсутствия результата"

std::variant (не подробно рассмотрен)

Альтернатива для более сложных сценариев

3. Сравнение подходов

Ситуация                Лучший подход
Критическая Ошибка    Исключения (throw)
Отсутствие значения     std::optional
Неверное состояние    Исключения (throw)
Ожидаемое поведение     std::optional
