1. Зачем понимать процесс компиляции?

Пока проект состоит из одного файла, можно работать и без глубоких знаний Понимание необходимо, когда:

 Проект разрастается до нескольких файлов
 Подключаются внешние библиотеки
 Возникают трудно диагностируемые ошибки

2. Четыре этапа компиляции

Процесс превращения исходного кода в исполняемую программу состоит из 4 шагов:

Этап 1: Препроцессинг

 Что происходит: Препроцессор обрабатывает директивы, начинающиеся с #
 Основные действия:
   Раскрывает #include (вставляет содержимое заголовочных файлов)
   Подставляет значения вместо макросов #define
   Обрабатывает условную компиляцию #ifdef / #ifndef
 Важно: Препроцессор работает с текстом и не знает синтаксиса C++

Этап 2: Компиляция

 Что происходит: Компилятор анализирует код, полученный после препроцессора
 Основные действия:
   Проверяет синтаксис и соответствие типов
   Генерирует объектный код (файлы с расширением .o в Linux/macOS или .obj в Windows)
 Ошибки на этом этапе: синтаксические ошибки, несоответствие типов

Этап 3: Ассемблирование

 Что происходит: Трансляция кода из объектного в машинный (бинарный) код
 Особенность: Обычно выполняется автоматически компилятором и редко выделяется как отдельный шаг

Этап 4: Линковка (Компоновка)

 Что происходит: Линковщик (компоновщик) собирает итоговый исполняемый файл из всех объектных файлов и библиотек
 Основные действия:
   Соединяет все .o / .obj файлы в один
   Ищет реализации вызванных функций
   Подключает статические и динамические библиотеки
 Ошибки на этом этапе:
   undefined reference / unresolved external symbol (нет реализации функции)

3. Роль заголовочных файлов (.h)

 Назначение: Разделение кода на интерфейс и реализацию
 .h файлы: Содержат объявления (прототипы функций, классы, глобальные переменные с extern) Это интерфейс для других частей программы
 .cpp файлы: Содержат реализацию (тела функций)
 Почему так правильно:
   Упрощает поддержку и навигацию по коду
   Предотвращает дублирование кода
   Позволяет компилятору проверять соответствие вызовов и реализаций

4. Единицы трансляции

 Каждый .cpp файл компилируется в отдельный объектный файл независимо
 Именно поэтому .h файлы с объявлениями необходимы - они говорят компилятору, какие функции существуют в других .cpp файлах, чтобы он мог временно "поверить" и продолжить компиляцию текущего файла

5. Типичные ошибки линковки

1. Отсутствие реализации: Объявление функции есть (в .h), но её тело не написано (в .cpp)
2. Множественное определение: Функция реализована в двух разных .cpp файлах (или дважды определена в одном), и линковщик не знает, какой вариант выбрать

6. Режимы сборки

 Debug:
   Скорость: медленная
   Проверки: много (включены ассерты, отладочная информация)
   Отладка: удобно отлаживать (есть информация о строках, переменных)
   Оптимизация: отключена (-O0)
 Release:
   Скорость: быстрая
   Проверки: минимум
   Отладка: сложнее дебажить из-за оптимизаций
   Оптимизация: включена (например, -O2, -O3)

7. Флаги компилятора (на примере GCC/Clang)

 -Wall: Включить основные предупреждения (рекомендуется всегда использовать)
 -O0, -O2: Уровни оптимизации
 -g: Добавить отладочную информацию (для Debug)
 -o <имя>: Задать имя выходного файла

8. Роль IDE

Интегрированная среда разработки (IDE) скрывает детали компиляции для удобства: она сама вызывает компилятор и линковщик с нужными флагами Это удобно, но создает иллюзию простоты Понимание процессов необходимо для решения сложных проблем

9. Статические и динамические библиотеки

 Статические (.a, .lib): Копия кода библиотеки включается прямо в ваш исполняемый файл на этапе линковки
 Динамические (.so, .dll): Библиотека подключается во время работы программы; код библиотеки хранится отдельно
